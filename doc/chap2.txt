  
  [1X2 [33X[0;0YQuickstart[133X[101X
  
  [33X[0;0YThis  chapter  is  intended for those who would like to get started with [5XQPA[105X
  right  away  by  playing  with  a  few  examples. We assume that the user is
  familiar with [5XGAP[105X syntax, for instance the different ways to display various
  [5XGAP[105X objects: [10XView[110X, [10XPrint[110X and [10XDisplay[110X. These features are all implemented for
  the  objects defined in [5XQPA[105X, and by using [10XDisplay[110X on an object, you will get
  a complete description of it.[133X
  
  [33X[0;0YThe  following  examples  show  how to create the most fundamental algebraic
  structures  featured  in [5XQPA[105X, namely quivers, path algebras and quotients of
  path  algebras,  modules  and module homomorphisms. Sometimes, there is more
  than  one  way of constructing such objects. See their respective chapter in
  the  documentation for more on this. The code from the examples can be found
  in the [10Xexamples/[110X directory of the distribution of [5XQPA[105X.[133X
  
  
  [1X2.1 [33X[0;0YExample 1 -- quivers, path algebras and quotients of path algebras[133X[101X
  
  [33X[0;0YWe  construct  a quiver [23XQ[123X, i.e. a finite directed graph, with one vertex and
  two loops:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := Quiver( 1, [ [1,1,"a"], [1,1,"b"] ] );[127X[104X
    [4X[28X<quiver with 1 vertices and 2 arrows>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(Q);[127X[104X
    [4X[28XQuiver( ["v1"], [["v1","v1","a"],["v1","v1","b"]] )[128X[104X
  [4X[32X[104X
  
  [33X[0;0YWhen  displaying  [23XQ[123X,  we observe that the vertex has been named [10Xv1[110X, and that
  this  name  is  used  when  describing  the  arrows. (The "Display" style of
  viewing  a  quiver  can  also  be  used in construction, i.e., we could have
  written  [10XQ := Quiver( ["v1"], [["v1","v1","a"],["v1","v1","b"]] )[110X to get the
  same object.)[133X
  
  [33X[0;0YIf  we want to know the number and names of the vertices and arrows, without
  getting  the structure of [23XQ[123X, we can request this information as shown below.
  We can also access the vertices and arrows directly.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XVerticesOfQuiver(Q);[127X[104X
    [4X[28X[ v1 ][128X[104X
    [4X[25Xgap>[125X [27XArrowsOfQuiver(Q);[127X[104X
    [4X[28X[ a, b ][128X[104X
    [4X[25Xgap>[125X [27XQ.a;[127X[104X
    [4X[28Xa[128X[104X
  [4X[32X[104X
  
  [33X[0;0YThe  next  step  is  to  create  the  path algebra [23XkQ[123X from [23XQ[123X, where [23Xk[123X is the
  rational numbers (in general, one can chose any field implemented in [5XGAP[105X).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XkQ := PathAlgebra(Rationals, Q);[127X[104X
    [4X[28X<Rationals[<quiver with 1 vertices and 2 arrows>]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(kQ);[127X[104X
    [4X[28X<Path algebra of the quiver <quiver with 1 vertices and 2 arrows> [128X[104X
    [4X[28Xover the field Rationals>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YWe  know  that this algebra has three generators, with the vertex [10Xv_1[110X as the
  identity.  This  can  be  verified by [5XQPA[105X. For convenience, we introduce new
  variables [10Xv1[110X, [10Xa[110X and [10Xb[110X to get easier access to the generators.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XAssignGeneratorVariables(kQ);[127X[104X
    [4X[28X#I  Assigned the global variables [ v1, a, b ][128X[104X
    [4X[25Xgap>[125X [27Xv1; a; b;[127X[104X
    [4X[28X(1)*v1[128X[104X
    [4X[28X(1)*a[128X[104X
    [4X[28X(1)*b[128X[104X
    [4X[25Xgap>[125X [27Xid := One(kQ);[127X[104X
    [4X[28X(1)*v1[128X[104X
    [4X[25Xgap>[125X [27Xv1 = id;[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [33X[0;0YNow, we want to construct a finite dimensional algebra, by dividing out some
  ideal.  The  generators  of  the ideal (the relations) are given in terms of
  paths,  and  it is important to know the convention of writing paths used in
  [5XQPA[105X. If we first go the arrow [23Xa[123X and then the arrow [23Xb[123X, the path is written as
  [23Xa*b[123X.[133X
  
  [33X[0;0YSay  that  we  want  our ideal to be generated by the relations [10X\{a^2, a*b -
  b*a,  b^2\}[110X. Then we make a list [10Xrelations[110X consisting of these relations and
  to  construct the quotient we say: [10XA := kQ/relations;[110X on the command line in
  [5XGAP[105X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xrelations := [a^2,a*b-b*a, b*b];[127X[104X
    [4X[28X[ (1)*a^2, (1)*a*b+(-1)*b*a, (1)*b^2 ][128X[104X
    [4X[25Xgap>[125X [27XA := kQ/relations;[127X[104X
    [4X[28X<Rationals[<quiver with 1 vertices and 2 arrows>]/<two-sided ideal in [128X[104X
    [4X[28X<Rationals[<quiver with 1 vertices and 2 arrows>]>, (3 generators)>>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YSee [14X4.6[114X for further remarks on constructing quotients of path algebras.[133X
  
  
  [1X2.2 [33X[0;0YExample 2 -- Introducing modules[133X[101X
  
  [33X[0;0YIn  representation  theory,  there  are  several  conventions for expressing
  modules  of  path  algebras,  and  again  it  is  useful  to  comment on the
  convention  used in [5XQPA[105X. A module (or representation) of an algebra [23XA = kQ/I[123X
  is,  briefly  explained,  a  picture  of  [23XQ[123X  where  the  vertices are finite
  dimensional  [23Xk[123X-vectorspaces,  and  the  arrows  are  linear  transformations
  between  the  vector  spaces  respecting the relations of [23XI[123X. The modules are
  [13Xright[113X modules, and a linear transformation from [23Xk^n[123X to [23Xk^m[123X is represented by
  a [23Xn \times m[123X-matrix.[133X
  
  [33X[0;0YThere  are  several  ways  of  constructing  modules  in [23XQPA[123X. First, we will
  explore  some modules which [23XQPA[123X gives us for free, namely the indecomposable
  projectives.  We  start by constructing a new algebra. The underlying quiver
  has  three  vertices and three arrows and looks like an [23XA_3[123X quiver with both
  arrows  pointing  to the right, and one additional loop in the final vertex.
  The only relation is to go this loop twice.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XQ := Quiver( 3, [ [1,2,"a"], [2,3,"b"], [3,3,"c"] ]);[127X[104X
    [4X[28X<quiver with 3 vertices and 3 arrows>[128X[104X
    [4X[25Xgap>[125X [27XkQ := PathAlgebra(Rationals, Q);[127X[104X
    [4X[28X<Rationals[<quiver with 3 vertices and 3 arrows>]>[128X[104X
    [4X[25Xgap>[125X [27Xrelations := [kQ.c*kQ.c];[127X[104X
    [4X[28X[ (1)*c^2 ][128X[104X
    [4X[25Xgap>[125X [27XA := kQ/relations;[127X[104X
    [4X[28X<Rationals[<quiver with 3 vertices and 3 arrows>]/[128X[104X
    [4X[28X<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, [128X[104X
    [4X[28X  (1 generators)>>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YThe  indecomposable  projectives are easily created with one command. We use
  [10XDisplay[110X to explore the modules.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xprojectives := IndecProjectiveModules(A);[127X[104X
    [4X[28X[ <[ 1, 1, 2 ]>, <[ 0, 1, 2 ]>, <[ 0, 0, 2 ]> ][128X[104X
    [4X[25Xgap>[125X [27Xproj1 := projectives[1];[127X[104X
    [4X[28X<[ 1, 1, 2 ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(proj1);[127X[104X
    [4X[28X<Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/[128X[104X
    [4X[28X<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, [128X[104X
    [4X[28X  (1 generators)>> with dimension vector [128X[104X
    [4X[28X[ 1, 1, 2 ]> and linear maps given by[128X[104X
    [4X[28Xfor arrow a:[128X[104X
    [4X[28X[ [  1 ] ][128X[104X
    [4X[28Xfor arrow b:[128X[104X
    [4X[28X[ [  1,  0 ] ][128X[104X
    [4X[28Xfor arrow c:[128X[104X
    [4X[28X[ [  0,  1 ],[128X[104X
    [4X[28X  [  0,  0 ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YIf  we, for some reason, want to use the maps of this module, we can get the
  matrices directly by using the command [10XMatricesOfPathAlgebraModule(proj1)[110X:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := MatricesOfPathAlgebraModule(proj1);[127X[104X
    [4X[28X[ [ [ 1 ] ], [ [ 1, 0 ] ], [ [ 0, 1 ], [ 0, 0 ] ] ][128X[104X
    [4X[25Xgap>[125X [27XM[1];[127X[104X
    [4X[28X[ [ 1 ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YNaturally,   the   indecomposable  injective  modules  are  just  as  easily
  constructed, and so are the simple modules.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xinjectives := IndecInjectiveModules(A);[127X[104X
    [4X[28X[ <[ 1, 0, 0 ]>, <[ 1, 1, 0 ]>, <[ 2, 2, 2 ]> ][128X[104X
    [4X[25Xgap>[125X [27Xsimples := SimpleModules(A);[127X[104X
    [4X[28X[ <[ 1, 0, 0 ]>, <[ 0, 1, 0 ]>, <[ 0, 0, 1 ]> ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YWe know for a fact that the simple module in vertex 1 and the indecomposable
  injective  module  in vertex 1 coincide. Let us look at this relationship in
  [5XQPA[105X:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xs1 := simples[1];[127X[104X
    [4X[28X<[ 1, 0, 0 ]>[128X[104X
    [4X[25Xgap>[125X [27Xinj1 := injectives[1];[127X[104X
    [4X[28X<[ 1, 0, 0 ]>[128X[104X
    [4X[25Xgap>[125X [27XIsIdenticalObj(s1,inj1);[127X[104X
    [4X[28Xfalse[128X[104X
    [4X[25Xgap>[125X [27Xs1 = inj1;[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsomorphicModules(s1,inj1);[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [33X[0;0YWe  observe  that  [5XQPA[105X  recognizes  the  modules  as  "the  same"  (that is,
  isomorphic);  however, they are [13Xnot[113X the same instance and hence the simplest
  test  for equality fails. This is important to bear in mind -- objects which
  are  isomorphic  and  regarded  as  the  same  in  the "real world", are not
  necessarily the same in [5XGAP[105X.[133X
  
  
  [1X2.3 [33X[0;0YExample 3 -- Constructing modules and module homomorphisms[133X[101X
  
  [33X[0;0YAssume  we  want  to construct the following [23XA[123X-module [23XM[123X, where [23XA[123X is the same
  algebra  as  in  the  previous  example  [22Xxymatrix0ar[r]^0  &  â„šar[r]^1  &  â„š
  ar@(ur,dr)^0[122X. This module is neither indecomposable projective or injective,
  nor  simple, so we need to do the dirty work ourselves. Usually, the easiest
  way  to construct a module is to state the dimension vector and the non-zero
  maps. Here, there is only one non-zero map, and we write[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := RightModuleOverPathAlgebra( A, [0,1,1], [ ["b", [[1]] ] ] );[127X[104X
    [4X[28X<[ 0, 1, 1 ]>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YTo  make  sure  we  got  everything right, we can use [10XDisplay(M)[110X to view the
  maps.  The  most  tricky  thing  is  usually  to  get the correct numbers of
  brackets.       Here       is      a      slightly      bigger      example:
  [22Xxymatrixâ„šar[r]^(beginsmallmatrix0         &        0endsmallmatrix)        &
  â„š^2ar[r]^(beginsmallmatrix1     &     0     -1    &    0endsmallmatrix)    &
  â„š^2ar@(ur,dr)^(beginsmallmatrix0 & 0 1 & 0endsmallmatrix)}[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XN := RightModuleOverPathAlgebra( A, [1,2,2], [ ["a",[[1,1]] ], [127X[104X
    [4X[28X   ["b", [[1,0], [-1,0]] ], ["c", [[0,0],[1,0]] ] ] );[128X[104X
    [4X[28X<[ 1, 2, 2 ]>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YNow we want to construct a map between the two modules, say [23Xf: M \rightarrow
  N[123X, which is non-zero only in vertex 2. This is done by[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xf := RightModuleHomOverAlgebra(M,N, [ [[0]], [[1,1]], NullMat(1,2,Rationals)]);[127X[104X
    [4X[28X<<[ 0, 1, 1 ]> ---> <[ 1, 2, 2 ]>>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(f);[127X[104X
    [4X[28X<<Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/[128X[104X
    [4X[28X<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, [128X[104X
    [4X[28X  (1 generators)>> with dimension vector [128X[104X
    [4X[28X[ 0, 1, 1 ]> ---> <Module over <Rationals[<quiver with 3 vertices and 3 arrows>]/[128X[104X
    [4X[28X<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>, [128X[104X
    [4X[28X  (1 generators)>> with dimension vector [ 1, 2, 2 ]>>[128X[104X
    [4X[28Xwith linear map for vertex number 1:[128X[104X
    [4X[28X[ [  0 ] ][128X[104X
    [4X[28Xlinear map for vertex number 2:[128X[104X
    [4X[28X[ [  1,  1 ] ][128X[104X
    [4X[28Xlinear map for vertex number 3:[128X[104X
    [4X[28X[ [  0,  0 ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YNote the two different ways of writing zero maps. Again, we can retrieve the
  matrices describing [23Xf[123X:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XMatricesOfPathAlgebraMatModuleHomomorphism(f);[127X[104X
    [4X[28X[ [ [ 0 ] ], [ [ 1, 1 ] ], [ [ 0, 0 ] ] ][128X[104X
  [4X[32X[104X
  
