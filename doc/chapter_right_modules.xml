<Chapter Label="Right-Modules"><Heading>Right Modules over Path
Algebras</Heading>

There are two implementations of right modules over path algebras.
The first type are matrix modules that are defined by vector spaces and
linear transformations.  The second type is presentations defined by
vertex projective modules (see <Ref Sect="vertexproj"/>). 

<Section><Heading>Modules of matrix type</Heading> The first implementation of
right modules over path algebras views them as a collection of vector
spaces and linear transformations.  Each vertex in the path algebra is
associated with a vector space over the field of the algebra.  For
each vertex <Math>v</Math> of the algebra there is a vector space
<Math>V</Math>.  Arrows of the algebra are then associated with linear
transformations which map the vector space of the source vertex to the
vector space of the target vertex.  For example, if <Math>a</Math> is
an arrow from <Math>v</Math> to <Math>w</Math>, then there is a
transformation from vector space <Math>V</Math> to <Math>W</Math>.
Given the dimension vector of the module we want to construct, the
information we need to provide is the non-zero linear
transformations. The size of the matrices for the zero linear
transformation are given when we know the dimension
vector. Alternatively, if we enter all the transformations, we can
create the vector spaces of the correct dimension, and check to make
sure the dimensions all agree.  We can create a module in this way as
follows.<P/>

  <ManSection>
   <Oper Name="RightModuleOverPathAlgebra" Label="with dimension vector" Arg="A, dim_vector, gens" 
	 Comm=""/>
   <Oper Name="RightModuleOverPathAlgebra" Label="no dimension vector" Arg="A, mats" 
	 Comm=""/>
   <Oper Name="RightModuleOverPathAlgebraNC" Label="no dimension vector" Arg="A, mats" 
	 Comm=""/>
   <Description> 
    Arguments: <Arg>A</Arg> -- a (quotient of a) path algebra and <Arg>dim_vector</Arg> -- the dimension vector of the module, <Arg>gens</Arg> or <Arg>mats</Arg> -- a list of matrices. For further explanations, see below.
   <Br /></Description>
   <Returns>a module over a path algebra or over a qoutient of a path
   algebra.</Returns> 
   <Description>
      In the first function call, the second
      argument <Arg>dim_vector</Arg> is the dimension vector of the
      module, and the last argument <Arg>gens</Arg> (maybe an empty
      list <C>[]</C>) is a list of elements of the form <C>["label",matrix]</C>.
      This function constructs a right module over a (quotient of a)
      path algebra <Arg>A</Arg> with dimension
      vector <Arg>dim_vector</Arg>, and where the generators/arrows
      with a non-zero action is given in the list
      <Arg>gens</Arg>. The format of the list <Arg>gens</Arg> is
      [["a",[matrix_a]],["b",[matrix_b]],...], where "a" and "b" are
      labels of arrows used when the underlying quiver was created and
      matrix_? is the action of the algebra element corresponding to
      the arrow with label "?". The action of the arrows can be
      entered in any order. The function checks (i) if the
      algebra <Arg>A</Arg> is a (quotient of a) path algebra, (ii) if
      the matrices of the action of the arrows have the correct size
      according to the dimension vector entered, (iii) also whether or
      not the relations of the algebra are satisfied and (iv) if all 
      matrices are over the correct field.<P/>

      In the second function call, the list of matrices
      <Arg>mats</Arg> can take on three different forms. The function 
      checks (i), (ii), (iii) and (iv) as above.<P/>

      1) The argument <Arg>mats</Arg> can be a list of blocks of
      matrices where each block is of the form, `["name of
      arrow",matrix]'.  So if you named your arrows when you created
      the quiver, then you can associate a matrix with that arrow
      explicitly.<P/> 

      2) The argument <Arg>mats</Arg> is just a list of matrices, and
      the matrices will be associated to the arrows in the order of
      arrow creation.  If when creating the quiver, the
      arrow <Math>a</Math> was created first, then <Math>a</Math>
      would be associated with the first matrix.<P/>

      3) The method is very much the same as the second
      method. If <Arg>arrows</Arg> is a list of the arrows of the
      quiver (obtained for instance through <C>arrows :=
      ArrowsOfQuiver(Q);</C>), the argument <Arg>mats</Arg> can have
      the
      format <C>[[arrows[1],matrix_1],[arrows[2],matrix_2],.... ].</C><P/>

      If you would like the trivial vector space at any vertex, then
      for each incoming arrow "a", associate it with a list of the
      form <C>["a",[n,0]]</C> where n is the dimension of the vector
      space at the source vertex of the arrow.  Likewise for all
      outgoing arrows "b", associate them to a block of
      form <C>["b",[0,n]]</C> where n is the dimension of the vector
      space at the target vertex of the arrow.<P/>

      The third function call is the same as the second except that 
      the check (iv) is not performed.<P/> 

      A warning though, the function assumes that you do not mix the
      styles of inputting the matrices/linear transformations
      associated to the arrows in the quiver. Furthermore in the two
      last versions, each arrow needs to be assigned a matrix,
      otherwise an error will be returned.<P/>
   </Description>
  </ManSection>

  <ManSection>
   <Oper Name="RightAlgebraModuleToPathAlgebraMatModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a right module over an algebra. 
   <Br /></Description>
   <Returns>a module over a (qoutient of a) path algebra.</Returns> 
   <Description>
     This function constructs a right module over a (quotient of a)
     path algebra <M>A</M> from a RightAlgebraModule over the same
     algebra <M>A</M>. The function checks if <M>A</M> actually is a
     quotient of a path algebra and if the module <M>M</M> is finite
     dimensional and if not, it returns an error message.
   </Description>
  </ManSection> 

  <ManSection>
   <Oper Name="\=" Label="for two path algebra matrix modules" Arg="M,
								    N" Comm=""/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra matrix modules. 
   <Br /></Description>
   <Returns>true if  <Arg>M</Arg> and <Arg>N</Arg> has the same dimension 
   vectors and the same matrices defining the module structure.</Returns> 
  </ManSection> 

<Example><![CDATA[
gap> Q := Quiver(2, [[1, 2, "a"], [2, 1, "b"],[1, 1, "c"]]);
<quiver with 2 vertices and 3 arrows>
gap> P := PathAlgebra(Rationals, Q);
<Rationals[<quiver with 2 vertices and 3 arrows>]>
gap> matrices := [["a", [[1,0,0],[0,1,0]]], 
>  ["b", [[0,1],[1,0],[0,1]]],
>  ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], 
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap> M := RightModuleOverPathAlgebra(P,matrices);
<[ 2, 3 ]>
gap> mats := [ [[1,0,0], [0,1,0]], [[0,1],[1,0],[0,1]], 
>           [[0,0],[1,0]] ];; 
gap> N := RightModuleOverPathAlgebra(P,mats); 
<[ 2, 3 ]>
gap> arrows := ArrowsOfQuiver(Q);
[ a, b, c ]
gap> mats := [[arrows[1], [[1,0,0],[0,1,0]]],
>          [arrows[2], [[0,1],[1,0],[0,1]]], 
>          [arrows[3], [[0,0],[1,0]]]];;
gap> N := RightModuleOverPathAlgebra(P,mats); 
<[ 2, 3 ]>
gap> # Next we give the vertex simple associate to vertex 1. 
gap> M := RightModuleOverPathAlgebra(P,[["a",[1,0]],["b",[0,1]],
>              ["c",[[0]]]]);
<[ 1, 0 ]>
gap> # The zero module. 
gap> M := RightModuleOverPathAlgebra(P,[["a",[0,0]],["b",[0,0]],
>              ["c",[0,0]]]);
<[ 0, 0 ]>
gap> Dimension(M);
0
gap> Basis(M);
Basis( <[ 0, 0 ]>, ... )
gap> matrices := [["a", [[1,0,0],[0,1,0]]], ["b",
>  [[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], 
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap> M := RightModuleOverPathAlgebra(P,[2,3],matrices);
<[ 2, 3 ]>
gap> M := RightModuleOverPathAlgebra(P,[2,3],[]);  
<[ 2, 3 ]>
gap> A := P/[P.c^2 - P.a*P.b, P.a*P.b*P.c, P.b*P.c];         
<Rationals[<quiver with 2 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 3 arrows>]>
    , (4 generators)>>
gap> Dimension(A);
9
gap> Amod := RightAlgebraModule(A,\*,A);                       
<9-dimensional right-module over <Rationals[<quiver with 
2 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 3 arrows>]>
    , (4 generators)>>>
gap> RightAlgebraModuleToPathAlgebraMatModule(Amod);
<[ 4, 5 ]> ]]>
</Example>
</Section>

<Section><Heading>Categories Of Matrix Modules</Heading>

  <ManSection>
   <Filt Name="IsPathAlgebraMatModule" Arg="object" Comm=""/>
   <Returns> 
   true or false depending on whether <Arg>object</Arg> belongs to the category <Code>IsPathAlgebraMatModule</Code>.</Returns>
   <Description>
     These matrix modules fall under the category `IsAlgebraModule'
     with the added filter of `IsPathAlgebraMatModule'.  Operations
     available for algebra modules can be applied to path algebra
     modules.  See <Ref BookName="ref" Label="representations of
     algebras"/> for more details.

     These modules are also vector spaces over the field of the path
     algebra.  So refer to <Ref BookName="ref" Label="vector spaces"/>
     for descriptions of the basis and elementwise operations
     available.
   </Description>
  </ManSection> 
</Section>

<Section><Heading>Acting on Module Elements</Heading>

  <ManSection>
   <Oper Name="^" Label="a PathAlgebraMatModule element and a PathAlgebra element" Arg="m, p" Comm=""/>
   <Description> 
   Arguments: <Arg>m</Arg> -- an element in a module, <Arg>p</Arg> --
   an element in a quiver algebra.
   <Br /></Description>
   <Returns>
    the element <Arg>m</Arg> multiplied with <Arg>p</Arg>.
   </Returns>
   <Description>
    When you act on an module element <Math>m</Math> by an
    arrow <Math>a</Math> from <Math>v</Math> to <Math>w</Math>, the
    component of <Math>m</Math> from <Math>V</Math> is acted on
    by <Math>L</Math> the transformation associated to <Math>a</Math>
    and placed in the component <Math>W</Math>.  All other components
    are given the value <Math>0</Math>.
   </Description>
  </ManSection>

<Example><![CDATA[
gap> # Using the path algebra P from the above example. 
gap> matrices := [["a", [[1,0,0],[0,1,0]]], 
> ["b", [[0,1],[1,0],[0,1]]], ["c", [[0,0],[1,0]]]];
[ [ "a", [ [ 1, 0, 0 ], [ 0, 1, 0 ] ] ], 
  [ "b", [ [ 0, 1 ], [ 1, 0 ], [ 0, 1 ] ] ], 
  [ "c", [ [ 0, 0 ], [ 1, 0 ] ] ] ]
gap> M := RightModuleOverPathAlgebra(P,matrices);
<[ 2, 3 ]>
gap> B:=BasisVectors(Basis(M));
[ [ [ 1, 0 ], [ 0, 0, 0 ] ], [ [ 0, 1 ], [ 0, 0, 0 ] ], 
  [ [ 0, 0 ], [ 1, 0, 0 ] ], [ [ 0, 0 ], [ 0, 1, 0 ] ], 
  [ [ 0, 0 ], [ 0, 0, 1 ] ] ]
gap> B[1] + B[3];
[ [ 1, 0 ], [ 1, 0, 0 ] ]
gap> 4*B[2];
[ [ 0, 4 ], [ 0, 0, 0 ] ]
gap> m := 5*B[1] + 2*B[4]+B[5];
[ [ 5, 0 ], [ 0, 2, 1 ] ]
gap> m^(P.a*P.b-P.c);
[ [ 0, 5 ], [ 0, 0, 0 ] ]
gap> B[1]^P.a;
[ [ 0, 0 ], [ 1, 0, 0 ] ]
gap> B[2]^P.b;
[ [ 0, 0 ], [ 0, 0, 0 ] ]
gap> B[4]^(P.b*P.c);
[ [ 0, 0 ], [ 0, 0, 0 ] ] ]]>
</Example>
</Section>

<Section><Heading>Operations on representations</Heading>

<Example><![CDATA[
gap> Q  := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],
> [3,1,"e"]]);
<quiver with 3 vertices and 5 arrows>
gap> KQ := PathAlgebra(Rationals, Q);
<Rationals[<quiver with 3 vertices and 5 arrows>]>
gap> gens := GeneratorsOfAlgebra(KQ);
[ (1)*v1, (1)*v2, (1)*v3, (1)*a, (1)*b, (1)*c, (1)*d, (1)*e ]
gap> u := gens[1];; v := gens[2];;
gap> w := gens[3];; a := gens[4];;
gap> b := gens[5];; c := gens[6];;
gap> d := gens[7];; e := gens[8];;
gap> rels := [d*e,c^2,a*c*d-b*d,e*a];;
gap> A := KQ/rels;
<Rationals[<quiver with 3 vertices and 5 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 5 arrows>]>
    , (5 generators)>>
gap> mat := [["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],
> ["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;
gap> N := RightModuleOverPathAlgebra(A,mat);   
<[ 3, 2, 2 ]> ]]>
</Example>

<ManSection>
   <Oper Name="AnnihilatorOfModule" Arg="M" Comm="for a   
         PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>a basis of the annihilator of the module <Arg>M</Arg> in
     the finite dimensional algebra over which <Arg>M</Arg> is a
     module.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="BasicVersionOfModule" Arg="M" Comm="for a   
         PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns> a basic version of the entered module <Arg>M</Arg>, that
   is, if <Math>M \simeq M_1^{n_1} \oplus \cdots \oplus
   M_t^{n_t},</Math> where <Math>M_i</Math> is indecomposable, then
   <Math>M_1\oplus \cdots \oplus M_t</Math> is returned. At
   present, this function only work at best for finite dimensional
   (quotients of a) path algebra over a finite field. If <Arg>M</Arg> is
   zero, then <Arg>M</Arg> is returned.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="BlockDecompositionOfModule" Arg="M" Comm="for a   
         PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>a set of modules <Math>\{M_1,..., M_t\}</Math> such that
   <Math>M \simeq M_1\oplus \cdots \oplus M_t,</Math> where each
   <Math>M_i</Math> is isomorphic to <Math>X_i^{n_i}</Math> for some
   indecomposable module <Math>X_i</Math> and positive integer
   <Math>n_i</Math> for all <Math>i</Math>, where <M>X_i\not\simeq X_j</M> 
   for <M>i\neq j</M>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="BlockSplittingIdempotents" Arg="M" Comm="for a   
         PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>a set <Math>\{e_1,..., e_t\}</Math> of idempotents in the
   endomorphism of <Arg>M</Arg> such that <Math>M \simeq \Im e_1\oplus
   \cdots \oplus \Im e_t,</Math> where each <Math>\Im e_i</Math> is
   isomorphic to <Math>X_i^{n_i}</Math> for some module
   <Math>X_i</Math> and positive integer <Math>n_i</Math> for all
   <Math>i</Math>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="CommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
   Arguments: <Arg>M</Arg> and <Arg>N</Arg> -- two path algebra modules.
   <Br /></Description>
   <Returns>a list of four modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>X</Arg>, <Arg>V</Arg>], 
     where <Arg>X</Arg> is one common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ComplexityOfModule" Arg="M, n" Comm="for a
   PathAlgebraMatModule and a positive integer"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- path algebdra module, <Arg>n</Arg> -- a positive integer.
   <Br /></Description>
   <Returns>an estimate of the complexity of the module <Arg>M</Arg>. 
   </Returns>
   <Description>
     The function checks if the algebra over which the module
     <Arg>M</Arg> lives is known to have finite global dimension. If
     so, it returns complexity zero. Otherwise it tries to estimate
     the complexity in the following way. Recall that if a function
     <M>f(x)</M> is a polynomial in <M>x</M>, the degree of
     <M>f(x)</M> is given by <M>\lim_{n\to\infty} \frac{\log
     |f(n)|}{\log n}</M>. So then this function computes an estimate
     of the complexity of <Arg>M</Arg> by approximating the complexity
     by considering the limit <M>\lim_{m\to \infty} \log
     \frac{\dim(P(M)(m))}{\log m}</M> where <M>P(M)(m)</M> is the
     <M>m</M>-th projective in a minimal projective resolution of
     <Arg>M</Arg> at stage <M>m</M>.  This limit is estimated by
     <M>\frac{\log \dim(P(M)(n))}{\log n}</M>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DecomposeModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>a list of indecomposable modules whose direct sum is
     isomorphic to the module <Arg>M</Arg>. 
   </Returns>
   <Description>Warning: the function is not properly tested and it at
     best only works properly over finite fields. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="DecomposeModuleWithMultiplicities" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>a list of length two, where the first entry is a list of
     all indecomposable non-isomorphic direct summands of <Arg>M</Arg>
     and the second entry is the list of the multiplicities of these
     direct summand in the module <Arg>M</Arg>. 
   </Returns>
   <Description>Warning: the function is not properly tested and it at
     best only works properly over finite fields. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="Dimension" Label="for a PathAlgebraMatModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the dimension of the representation <Arg>M</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="DimensionVector" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the dimension vector of the representation <Arg>M</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="DirectSumOfQPAModules" Arg="L" Comm="for a
   list of PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>L</Arg> -- a list of <C>PathAlgebraMatModule</C>s over the same (quotient of a) path algebra. 
   <Br /></Description>
   <Returns>the direct sum of the representations contained in the
     list <Arg>L</Arg>.</Returns>
   <Description>In addition three attributes are attached to the
   result, <Ref Attr="IsDirectSumOfModules"/>, <Ref
   Attr="DirectSumProjections"/> <Ref Attr="DirectSumInclusions"/>.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="DirectSumInclusions" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    the list of inclusions from the individual
    modules to their direct sum, when a direct sum has been
    constructed using <Ref Oper="DirectSumOfQPAModules"/>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="DirectSumProjections" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    the list of projections from the direct sum to the individual
    modules used to construct direct sum, when a direct sum has been
    constructed using <Ref Oper="DirectSumOfQPAModules"/>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IntersectionOfSubmodules" Arg="list" Comm="for a list
   of PathAlgebraMatModule submodules"/>
   <Description> 
    Arguments: <Arg>f, g</Arg> or <Arg>list</Arg> -- two homomorphisms
    of PathAlgebraMatModules or a list of such.
   <Br /></Description>
   <Returns>the subrepresentation given by the intersection of all the
   submodules given by the inclusions  <Arg>f</Arg> and <Arg>g</Arg>
   or <Arg>list</Arg>.
   </Returns>
   <Description>The function checks if <Arg>list</Arg> is non-empty
   and if <Math><Arg>f</Arg>\colon M\to X</Math> and
   <Math><Arg>g</Arg>\colon N\to X</Math> or all the homomorphism in
   <Arg>list</Arg> have the same range and if they all are
   inclusions. If the function is given two arguments <Arg>f</Arg> and
   <Arg>g</Arg>, then it returns <Math>[f',g',g'*f]</Math>, where
   <Math>f'\colon E\to N</Math>, <Math>g'\colon E\to M</Math>, and
   <Math>E</Math> is the pullback of <Arg>f</Arg> and
   <Arg>g</Arg>. For a list of inclusions it returns a monomorphism
   from a module isomorphic to the intersection to <Math>X</Math>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="IsDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
   Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is isomorphic to a direct summand
     of <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="IsDirectSumOfModules" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>
    true if <Arg>M</Arg> is constructed via the command <Ref
    Oper="DirectSumOfQPAModules"/>.
   </Returns>
</ManSection>

Using the example above.
<Example><![CDATA[
gap> N2 := DirectSumOfQPAModules([N,N]);
<[ 6, 4, 4 ]>
gap> proj := DirectSumProjections(N2);
[ <<[ 6, 4, 4 ]> ---> <[ 3, 2, 2 ]>>
    , <<[ 6, 4, 4 ]> ---> <[ 3, 2, 2 ]>>
     ]
gap> inc := DirectSumInclusions(N2);
[ <<[ 3, 2, 2 ]> ---> <[ 6, 4, 4 ]>>
    , <<[ 3, 2, 2 ]> ---> <[ 6, 4, 4 ]>>
     ] ]]>
</Example>

<ManSection>
   <Prop Name="IsExceptionalModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is an exceptional module, otherwise
   false, if the field, over which the algebra <Arg>M</Arg> is defined over, is
   finite.
   </Returns>
   <Description>
     The module <Arg>M</Arg> is an exceptional module, if it is indecomposable and
     <M>\Ext^1(M,M)=(0)</M>. 
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsIndecomposableModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is an indecomposable module, if the
   field, over which the algebra <Arg>M</Arg> is defined over, is finite.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsInAdditiveClosure" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is in the additive closure of the module
     <Arg>N</Arg>, otherwise false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsInjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is injective.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="IsomorphicModules" Arg="M, N" Comm=""/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>true or false depending on whether <Arg>M</Arg>
   and <Arg>N</Arg> are isomorphic or not.</Returns> 
   <Description>
    The function first checks if the modules <Arg>M</Arg>
    and <Arg>N</Arg> are modules over the same algebra, and returns fail
    if not. The function returns true if the modules are
    isomorphic, otherwise false. 
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsProjectiveModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is projective.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsRigidModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is a rigid module, otherwise
   false. 
   </Returns>
   <Description>
     The module <Arg>M</Arg> is a rigid module, if <M>\Ext^1(M,M)=(0)</M>. 
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsSemisimpleModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is semisimple.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsSimpleQPAModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if the representation <Arg>M</Arg> is simple.
   </Returns>
</ManSection>

<ManSection>
   <Prop Name="IsTauRigidModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>true if <Arg>M</Arg> is a <M>\tau</M>-rigid module, otherwise
   false. 
   </Returns>
   <Description>
     The module <Arg>M</Arg> is a <M>\tau</M>-rigid module, if <M>\Hom(M,\tau M)=(0)</M>. 
   </Description>
</ManSection>

<ManSection>
   <Attr Name="LoewyLength" Label="for a PathAlgebraMatModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the Loewy length of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function checks that the module <Arg>M</Arg> is a module over
    a finite dimensional quotient of a path algebra, and returns fail
    otherwise (This is not implemented yet). 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="MatricesOfPathAlgebraModule" Arg="M" Comm="for a
   PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>a list of the matrices that defines the
     representation <Arg>M</Arg> as a right module of the acting path
     algebra.
   </Returns>
   <Description> 
     The list of matrices that are returned are not the same identical
     to the matrices entered to define the representation if there is
     zero vector space in at least one vertex. Then zero matrices of
     the appropriate size are returned.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="MaximalCommonDirectSummand" Arg="M, N" Comm="for two
   PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>a list of three modules [<Arg>X</Arg>,<Arg>U</Arg>,<Arg>V</Arg>], 
     where <Arg>X</Arg> is a maximal common non-zero direct summand of <Arg>M</Arg> 
     and <Arg>N</Arg>, the sum of <Arg>X</Arg> and <Arg>U</Arg> is  <Arg>M</Arg>
     and the sum of  <Arg>X</Arg> and <Arg>V</Arg> is  <Arg>N</Arg>, 
     if such a non-zero maximal direct summand exists. Otherwise it returns false.</Returns>
   <Description>The function checks if <Arg>M</Arg> and <Arg>N</Arg>
     are <C>PathAlgebraMatModule</C>s over the same (quotient of a)
     path algebra. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="NumberOfNonIsoDirSummands" Arg="M" Comm="for a PathAlgebraMatModule's"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra modules (<C>PathAlgebraMatModule</C>s).
   <Br /></Description>
   <Returns>a list with two elements: (1) the number of non-isomorphic
   indecomposable direct summands of the module <Arg>M</Arg> and (2)
   the dimensions of the simple blocks of the semisimple ring
   <Math>\End(M)/\rad \End(M)</Math>.</Returns>
</ManSection>

<ManSection>
   <Attr Name="MinimalGeneratingSetOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>a minimal generator set of the module <Arg>M</Arg> as a
   module of the path algebra it is defined over. </Returns>
</ManSection>

<ManSection>
   <Oper Name="RadicalOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the radical of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the radical of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="RadicalOfModuleInclusion"/> computes the inclusion of the
    radical of <Arg>M</Arg> into <Arg>M</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="RadicalSeries" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the radical series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the radical series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The first vector listed corresponds
     to the top layer, and so on.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleSeries" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the socle series of the module <Arg>M</Arg>.</Returns>
   <Description>
     The function gives the socle series as a list of vectors
     <Code>[n_1,...,n_s]</Code>, where the algebra has <Math>s</Math>
     isomorphism classes of simple modules and the numbers give the
     multiplicity of each simple. The last vector listed corresponds
     to the socle layer, and so on backwards.  
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SocleOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the socle of the module <Arg>M</Arg>.</Returns>
   <Description>
    This operation only return the representation given by the socle
    of the module <Arg>M</Arg>.  The inclusion the socle
    of <Arg>M</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SocleOfModuleInclusion"/>.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SubRepresentation" Arg="M, gens" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>), <Arg>gens</Arg> -- elements in <Arg>M</Arg>.
   <Br /></Description>
   <Returns>the submodule of the module <Arg>M</Arg> generated by the
   elements <Arg>gens</Arg>.</Returns>
   <Description>
    The function checks if <Arg>gens</Arg> are elements
    in <Arg>M</Arg>, and returns an error message otherwise. The
    inclusion of the submodule generated by the
    elements <Arg>gens</Arg> into <Arg>M</Arg> can be computed using
    <Ref Oper="SubRepresentationInclusion"/>.   
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SumOfSubmodules" Arg="list" Comm="for a list
   of PathAlgebraMatModule submodules"/>
   <Description> 
    Arguments: <Arg>f, g</Arg> or <Arg>list</Arg> -- two inclusions
    of PathAlgebraMatModules or a list of such.
   <Br /></Description>
   <Returns>the subrepresentation given by the sum of all the
   submodules given by the inclusions  <Arg>f, g</Arg>
   or <Arg>list</Arg>.
   </Returns>
   <Description>The function checks if <Arg>list</Arg> is non-empty
     and if <Math><Arg>f</Arg>\colon M\to X</Math>
     and <Math><Arg>g</Arg>\colon N\to X</Math> or all the
     homomorphism in <Arg>list</Arg> have the same range and if they
     all are inclusions. If the function is given two
     arguments <Arg>f</Arg> and <Arg>g</Arg>, then it
     returns <Math>[h,f',g']</Math>, where <Math>h\colon M + N\to
     X</Math>, <Math>f'\colon M\to M + N</Math> and <Math>g'\colon
     N\to M + N</Math>. For a list of
     inclusions it returns a monomorphism from a module isomorphic
     to the sum of the subrepresentations to <Math>X</Math>. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="SupportModuleElement" Arg="m" Comm=""/>
   <Description> 
    Arguments: <Arg>m</Arg> -- an element of a path algebra module.
   <Br /></Description>
   <Returns>the primitive idempotents <Arg>v</Arg> in the algebra over
   which the module containing the element <Arg>m</Arg> is a module,
   such that <Arg>m^v</Arg> is non-zero.</Returns>
   <Description>
    The function checks if <Arg>m</Arg> is an element in a module 
    over a (quotient of a) path algebra, and returns fail otherwise. 
   </Description>
</ManSection>

<ManSection>
   <Oper Name="TopOfModule" Arg="M" Comm=""/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module (<C>PathAlgebraMatModule</C>).
   <Br /></Description>
   <Returns>the top of the module <Arg>M</Arg>.</Returns>
   <Description>
    This returns only the representation given by the top of the
    module <Arg>M</Arg>. The operation
    <Ref Oper="TopOfModuleProjection"/> computes the projection of the
    module <Arg>M</Arg> onto the top of the module <Arg>M</Arg>. 
   </Description>
</ManSection>
</Section>

<Section><Heading>Special representations</Heading>
Here we collect the predefined representations/modules over a finite
  dimensional quotient of a path algebra. 

<ManSection>
    <Attr Name="BasisOfProjectives" Arg="A" Comm=""/>
    <Description> 
      Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
      algebra.
    <Br /></Description>
    <Returns>a list of bases for all the indecomposable projective
    representations over <Arg>A</Arg>. The basis for each indecomposable projective is given a list of elements in nontips in <Arg>A</Arg>. 
    </Returns>
    <Description>
      The function checks if the algebra <Arg>A</Arg> is a
      finite dimensional (quotient of a) path algebra, and returns an 
      error message otherwise. 
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="IndecInjectiveModules" Arg="A" Comm="for an algebra"/>
    <Description> 
      Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
      algebra.
    <Br /></Description>
    <Returns>a list of all the non-isomorphic indecomposable injective
    representations over <Arg>A</Arg>. 
    </Returns>
    <Description>
      The function checks if the algebra <Arg>A</Arg> is a finite
      dimensional (quotient of a) path algebra, and returns an error
      message otherwise. 
    </Description>
  </ManSection>
  
  <ManSection>
    <Attr Name="IndecProjectiveModules" Arg="A" Comm="for an algebra"/>
    <Description> 
      Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
      algebra.
    <Br /></Description>
    <Returns>a list of all the non-isomorphic indecomposable projective
    representations over <Arg>A</Arg>. 
    </Returns>
    <Description>
      The function checks if the algebra <Arg>A</Arg> is a
      finite dimensional (quotient of a) path algebra, and returns an 
      error message otherwise. 
    </Description>
  </ManSection>

  <ManSection>
    <Attr Name="SimpleModules" Arg="A" Comm=""/>
    <Description> 
      Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
      algebra.
    <Br /></Description>
    <Returns>a list of all the simple representations over <Arg>A</Arg> .
    </Returns>
    <Description>
      The function checks if the algebra <Arg>A</Arg> is a finite
      dimensional (quotient of a) path algebra, and returns an error
      message otherwise. 
    </Description>
  </ManSection>
  
  <ManSection>
    <Attr Name="ZeroModule" Arg="A" Comm=""/>
    <Description> 
      Arguments: <Arg>A</Arg> -- a finite dimensional (quotient of a) path
      algebra.
    <Br /></Description>
    <Returns>the zero representation over <Arg>A</Arg>.
    </Returns>
    <Description>
      The function checks if the algebra <Arg>A</Arg> is a finite
      dimensional (quotient of a) path algebra, and returns an error
      message otherwise. 
    </Description>
  </ManSection>
</Section>


<Section><Heading>Functors on representations</Heading>

<ManSection>
   <Attr Name="DualOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a <C>PathAlgebraMatModule</C>.
   <Br /></Description>
   <Returns>
    the dual of <Arg>M</Arg> over the opposite algebra <M>A^\op</M>,
    if <Arg>M</Arg> is a module over <M>A</M>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="DualOfModuleHomomorphism" Arg="f" Comm="for a PathAlgebraMatModuleMap"/>
   <Description> 
    Arguments: <Arg>f</Arg> -- a map between two representations <Arg>M</Arg> and <Arg>N</Arg> over a path algebra <Math>A</Math>.
   <Br /></Description>
   <Returns>
    the dual of this map over the opposite path algebra <Arg>A^\op</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="DTr" Arg="M, [ n ]" Comm="for a PathAlgebraMatModule and an
   integer"/>
   <Oper Name="DualOfTranspose" Arg="M, [ n ]" Comm="for a
   PathAlgebraMatModule"/> 
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module, (optional) <Arg>n</Arg> -- an integer.
   <Br /></Description>
   <Returns>the dual of the transpose of <Arg>M</Arg> when
   called with only one argument, while it returns the dual of the
   transpose applied to <Arg>M</Arg> <Arg>n</Arg> times
   otherwise. If <Arg>n</Arg> is negative, then powers of <C>TrD</C>
   are computed. <Ref Oper="DualOfTranspose"/> is a synonym for
   <Ref Oper="DTr"/>. </Returns>
</ManSection>

<ManSection>
   <Attr Name="NakayamaFunctorOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a <C>PathAlgebraMatModule</C>.
   <Br /></Description>
   <Returns>
    the module <M>\Hom_K(\Hom_A(M,A), K)</M> over <M>A</M>, when
    <Arg>M</Arg> is a module over a <M>K</M>-algebra <M>A</M>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="NakayamaFunctorOfModuleHomomorphism" Arg="f" Comm="for a PathAlgebraMatModuleMap"/>
   <Description> 
    Arguments: <Arg>f</Arg> -- a map between two modules <Arg>M</Arg>
    and <Arg>N</Arg> over a path algebra <Math>A</Math>.  <Br/>
   </Description>
   <Returns>
    the homomorphism induced by <M>f\colon M\to N</M> from the module
    <M>\Hom_K(\Hom_A(M,A),K)</M> to <M>\Hom_K(\Hom_A(N,A), K)</M>,
    when <Arg>f</Arg> is a module homomorphism over a <M>K</M>-algebra
    <Arg>A</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="StarOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a <C>PathAlgebraMatModule</C>.
   <Br /></Description>
   <Returns>
    the module <M>\Hom_A(M,A)</M> over the opposite of <M>A</M>,
    when <Arg>M</Arg> is a module over an algebra <M>A</M>. 
   </Returns>
</ManSection>

<ManSection>
   <Attr Name="StarOfModuleHomomorphism" Arg="f" Comm="for a PathAlgebraMatModuleMap"/>
   <Description> 
    Arguments: <Arg>f</Arg> -- a map between two modules <Arg>M</Arg>
    and <Arg>N</Arg> over a path algebra <Math>A</Math>.  <Br/>
   </Description>
   <Returns>
    the homomorphism induced by <M>f\colon M\to N</M> from the module
    <M>\Hom_A(N,A)</M> to <M>\Hom_A(M,A)</M>, when <Arg>f</Arg> is a
    module homomorphism over an algebra  <Arg>A</Arg>.
   </Returns>
</ManSection>

<ManSection>
   <Oper Name="TrD" Arg="M, [n]" Comm="for a PathAlgebraMatModule and an
   integer"/>
   <Oper Name="TransposeOfDual" Arg="M, [n]" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module, (optional) <Arg>n</Arg> -- an integer.
   <Br /></Description>
   <Returns>the transpose of the dual of <Arg>M</Arg> when
   called with only one argument, while it returns the transpose of
   the dual applied to <Arg>M</Arg> <Arg>n</Arg> times
   otherwise. If <Arg>n</Arg> is negative, then powers of <C>TrD</C>
   are computed. <Ref Oper="TransposeOfDual"/> is a synonym for
   <Ref Oper="TrD"/>.</Returns>
</ManSection>

<ManSection>
   <Attr Name="TransposeOfModule" Arg="M" Comm="for a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a path algebra module.
   <Br /></Description>
   <Returns>the transpose of the module <Arg>M</Arg>.</Returns>
</ManSection>

</Section>

<Section Label="vertexproj"><Heading>Vertex projective modules and submodules thereof</Heading> 
In general, if <Math>R</Math> is a ring and <Math>e</Math> is an
idempotent of <Math>R</Math>, then <Math>eR</Math> is a projective
module of <Math>R</Math>.  Then we can form a direct sum of these
projective modules together to form larger projective module.

One can construct more general modules by providing a <Arg>vertex
projective presentation</Arg>.  In this case, <Math>M</Math> is the
cokernel as given by the following exact sequence:

<Math>\oplus_{j=1}^{r} w(j)R \rightarrow \oplus_{i=1}^{g} v(i)R
\rightarrow{M} \rightarrow 0</Math>

for some map between <Math>\oplus_{j=1}^{r} w(j)R</Math>
and <Math>\oplus_{i=1}^{g} v(i)R</Math>.  The maps <Math>w</Math>
and <Math>v</Math> map the integers to some idempotent
in <Math>R</Math>.

<ManSection>
   <Func Name="RightProjectiveModule" Arg="A, verts" 
	 Comm=""/>
	 <Description> 
    Arguments: <Arg>A</Arg> -- a (quotient of a) path algebra, <Arg>verts</Arg> -- a list of vertices.
   <Br /></Description>
   <Returns> the right projective module over <Arg>A</Arg> which is
      the direct sum of projective modules of the form <Arg>vA</Arg>
      where the vertices are taken from <Arg>verts</Arg>.</Returns>
   <Description>
     The module created is in the category <C>IsPathAlgebraModule</C>. 

     In this implementation the algebra can be a quotient of a path
     algebra.  So if the list was
     <Math>[v,w]</Math> then the module created will be the direct
     sum <Math>vA \oplus wA</Math>, in that order.  Elements of the
     modules are vectors of algebra elements, and in each component,
     each path begins with the vertex in that position in the list of
     vertices.  Right projective modules are implementated as algebra
     modules (see <Ref BookName="ref" Label="representations of algebras"/>) and all
     operations for algebra modules are applicable to right
     projective modules.  In particular, one can construct submodules
     using <Ref BookName="ref" Func="SubAlgebraModule"/>.
   </Description>
</ManSection>
Here we create the right projective module <Math>P = vA \oplus vA
\oplus wA</Math>. 

<Example><![CDATA[
gap> F := GF(11);
GF(11)
gap> Q := Quiver(["v","w", "x"],[["v","w","a"],["v","w","b"],
> ["w","x","c"]]);
<quiver with 3 vertices and 3 arrows>
gap> A := PathAlgebra(F,Q);
<GF(11)[<quiver with 3 vertices and 3 arrows>]>
gap> P := RightProjectiveModule(A,[A.v,A.v,A.w]);
<right-module over <GF(11)[<quiver with 3 vertices and 3 arrows>]>>
gap> Dimension(P);
12 ]]>
</Example>

<ManSection>
   <Func Name="CompletelyReduceGroebnerBasisForModule" Arg="GB" Comm="for a right Groebner basis of a module"/>
	 <Description> 
    Arguments: <Arg>GB</Arg> -- an right Groebner basis for a (submodule of a) vertex projective module over a path algebra. 
   <Br /></Description>
   <Returns>a completely reduced right Groebner basis from the entered Groebner basis <Arg>GB</Arg>.</Returns>
   <Description>
     This function takes as input an right Groebner basis for a vertex
     projective module or a submodule thereof, an constructs
     completely reduced right Groebner from it.
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsLeftDivisible" Arg="x, y" Comm="for two PathAlgebraVector's"/>
   <Description> 
    Arguments: <Arg>x, y</Arg> -- two path algebra vectors.
   <Br /></Description>
   <Returns>true if the tip of  <Arg>y</Arg>  left divides the tip of  <Arg>x</Arg>.  
   False otherwise.</Returns>
   <Description>
     Given two PathAlgebraVectors <Arg>x</Arg> and <Arg>y</Arg>, then
     <Arg>y</Arg> is said to left divide <Arg>x</Arg>, if the tip of
     <Arg>x</Arg> and the tip of <Arg>y</Arg> occur in the same
     coordinate, and the tipmonomial of the tip of <Arg>y</Arg>
     leftdivides the tipmonomial of the tip of <Arg>x</Arg>.
   </Description>
</ManSection>

<ManSection>
   <Prop Name="IsPathAlgebraModule" Arg="P" Comm="an object"/>
   <Description> 
    Arguments: <Arg>P</Arg> -- any object.
   <Br /></Description>
   <Returns>true if the argument <Arg>P</Arg> is in the category <C>IsPathAlgebraModule</C>.</Returns>
</ManSection>

<ManSection>
   <Prop Name="IsPathAlgebraVector" Arg="v" Comm="for a PathAlgebraVector"/>
   <Description> 
    Arguments: <Arg>v</Arg> -- a path algebra vector.
   <Br /></Description>
   <Returns>true if <Arg>v</Arg> has been constructed as a PathAlgebraVector.
   Otherwise it returns false.</Returns>
</ManSection>

<ManSection>
  <Oper Name="LeadingCoefficient (of PathAlgebraVector)" Arg="x" Comm="for a PathAlgebraVector"/>
  <Description> 
    Arguments: <Arg>x</Arg> -- an element in a PathAlgebraModule. 
  <Br /></Description>
  <Returns>the coefficient of the leading term/tip of a <C>PathAlgebraVector</C>.</Returns>
  <Description>
    The tip of the element <Arg>x</Arg> can by found by applying the 
    command <Ref Oper="LeadingTerm (of PathAlgebraVector)"/>. 
  </Description>
</ManSection>

<ManSection>
   <Oper Name="LeadingComponent" Arg="v" Comm="for a PathAlgebraVector"/>
   <Description> 
    Arguments: <Arg>v</Arg> -- a path algebra vector.
   <Br /></Description>
   <Returns><C>v[pos]</C>, where <C>pos</C> is the coordinate for the tip 
   of the vector, whenever <Arg>v</Arg> is non-zero. That is, it returns the coordinate
   of the vector <Arg>v</Arg> where the tip occors. It returns zero otherwise.</Returns>
</ManSection>

<ManSection>
   <Oper Name="LeadingPosition" Arg="v" Comm="for a PathAlgebraVector"/>
   <Description> 
    Arguments: <Arg>v</Arg> -- a path algebra vector.
   <Br /></Description>
   <Returns>the coordinate in which the tip of the vector occurs.</Returns>
</ManSection>

<ManSection>
  <Oper Name="LeadingTerm (of PathAlgebraVector)" Arg="x" 
	Comm=""/>
  <Description> 
    Arguments: <Arg>x</Arg> -- an element in a PathAlgebraModule. 
  <Br /></Description>
  <Returns>the leading term/tip of a <C>PathAlgebraVector</C>.</Returns>
  <Description>
    The tip of the element <Arg>x</Arg> is computed using the
    following order: the tip is computed for each coordinate, if the
    largest of these occur as a tip of several coordinates, then the
    coordinate with the smallest index from 1 to the length of vector
    is chosen. The position of the tip was computed when the
    <C>PathAlgebraVector</C> was created.
  </Description>
</ManSection>

<ManSection>
   <Oper Name="LeftDivision" Arg="x, y" Comm="for two PathAlgebraVector's"/>
   <Description> 
    Arguments: <Arg>x, y</Arg> -- two path algebra vectors.
   <Br /></Description>
   <Returns>a scalar multiple of a path, say <Math>\lambda</Math> such
   that the tips of <Math>y*\lambda</Math> and <Math>x</Math> are the same,
   if the tip of <Arg>y</Arg> left divides the tip of <Arg>x</Arg>.
   False otherwise.</Returns>
</ManSection>

In the following example, we create two elements in <Math>P</Math>,
perform some elementwise operations, and then construct a submodule
using the two elements as generators.<P/>

<Example><![CDATA[
gap> p1 := Vectorize(P,[A.b*A.c,A.a*A.c,A.c]);
[ (Z(11)^0)*b*c, (Z(11)^0)*a*c, (Z(11)^0)*c ]
gap> p2 := Vectorize(P,[A.a,A.b,A.w]);
[ (Z(11)^0)*a, (Z(11)^0)*b, (Z(11)^0)*w ]
gap> 2*p1 + p2;
[ (Z(11)^0)*a+(Z(11))*b*c, (Z(11)^0)*b+(Z(11))*a*c, 
  (Z(11)^0)*w+(Z(11))*c ]
gap> S := SubAlgebraModule(P,[p1,p2]);
<right-module over <GF(11)[<quiver with 3 vertices and 3 arrows>]>>
gap> Dimension(S);
3 ]]>
</Example>

  <ManSection>
   <Oper Name="^" Label="a PathAlgebraModule element and a PathAlgebra element" Arg="m, a" Comm="Action by a path algebra element"/>
   <Description> 
    Arguments: <Arg>m</Arg> -- an element of a path algebra module, <Arg>a</Arg> -- an element of a path algebra.
   <Br /></Description>
   <Returns>
    the element <Arg>m</Arg> multiplied with <Arg>a</Arg>.
   </Returns>
   <Description>
    This action is defined by multiplying each component
    in <Arg>m</Arg> by <Arg>a</Arg> on the right.
   </Description>
  </ManSection>

<Example><![CDATA[
gap> p2^(A.c - A.w);
[ (Z(11)^5)*a+(Z(11)^0)*a*c, (Z(11)^5)*b+(Z(11)^0)*b*c, 
  (Z(11)^5)*w+(Z(11)^0)*c ] ]]>
</Example>

  <ManSection>
   <Oper Name="&lt;" Label="for two elements in a PathAlgebraModule" Arg="m1, m2" Comm="lessthan"/>
   <Description> 
    Arguments: <Arg>m1, m2</Arg> -- two elements of a PathAlgebraModule.
   <Br /></Description>
   <Returns>
    `true' if <Arg>m1</Arg> is less than <Arg>m2</Arg> and false otherwise.
   </Returns>
   <Description>
    Elements are compared componentwise from left to right using the ordering of the underlying algebra.  The element <Arg>m1</Arg> is less than <Arg>m2</Arg> if the first time components are not equal, the
    component of <Arg>m1</Arg> is less than the corresponding
    component of <Arg>m2</Arg>.
   </Description>
  </ManSection>

<Example><![CDATA[
gap> p1 < p2;
false ]]>
</Example>

  <ManSection>
   <Oper Name="/" Arg="M, N" Comm="Factor module"/>
   <Description> 
    Arguments: <Arg>M, N</Arg> -- two finite dimensional <C>PathAlgebraModule</C>s.
   <Br /></Description>
   <Returns>
    the factor module <Math>M/N</Math>.
   </Returns>
   <Description>
    This module is
    again a right algebra module, and all applicable methods and
    operations are available for the resulting factor module.
    Furthermore, the resulting module is a vector space, so operations
    for computing bases and dimensions are also available.
   </Description>
  </ManSection>

<Example><![CDATA[
gap> PS := P/S;
<9-dimensional right-module over <GF(11)[<quiver with 3 vertices and 
3 arrows>]>>
gap> Basis(PS);
Basis( <9-dimensional right-module over <GF(11)[<quiver with 
3 vertices and 3 arrows>]>>, 
[ [ [ <zero> of ..., (Z(11)^0)*v, <zero> of ... ] ], 
  [ [ (Z(11)^0)*v, <zero> of ..., <zero> of ... ] ], 
  [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*w ] ], 
  [ [ <zero> of ..., (Z(11)^0)*a, <zero> of ... ] ], 
  [ [ (Z(11)^0)*a, <zero> of ..., <zero> of ... ] ], 
  [ [ (Z(11)^0)*b, <zero> of ..., <zero> of ... ] ], 
  [ [ <zero> of ..., <zero> of ..., (Z(11)^0)*c ] ], 
  [ [ <zero> of ..., (Z(11)^0)*a*c, <zero> of ... ] ], 
  [ [ (Z(11)^0)*a*c, <zero> of ..., <zero> of ... ] ] ] ) ]]>
</Example>

<ManSection>
   <Oper Name="PathAlgebraVector" Arg="fam, components" Comm="for a PathAlgebraVectorFamily and a list"/>
   <Description> 
    Arguments: <Arg>fam</Arg> -- a PathAlgebraVectorFamily, <Arg>components</Arg> -- a homogeneous list of elements. 
   <Br /></Description>
   <Returns>a PathAlgebraVector in the PathAlgebraVectorFamily <Arg>fam</Arg> with the components of the vector being 
   equal to <Arg>components</Arg>. 
   </Returns>
   <Description>
     This function is typically used when constructing elements of a module 
     constructed by the command <C>RightProjectiveModule</C>. If <C>P</C> is 
     constructed as say, <C>P := RightProjectiveModule(KQ, [KQ.v1, KQ.v1, KQ.v2])</C>, 
     then <C>ExtRepOfObj(p)</C>, where <C>p</C> is an element if <C>P</C> is
     a <C>PathAlgebraVector</C>. The tip is computed using the following 
     ordering: the tip is computed for each coordinate, if the largest of 
     these occur as a tip of several coordinates, then the coordinate with 
     the smallest index from 1 to the length of vector is chosen.
   </Description>
</ManSection>

<ManSection>
   <Oper Name="ProjectivePathAlgebraPresentation" Arg="M" Comm="projective presentation of a PathAlgebraMatModule"/>
   <Description> 
    Arguments: <Arg>M</Arg> -- a finite dimensional module over a (quotient of a) path algebra.
   <Br /></Description>
   <Returns>a projective presentation of the entered module
   <Arg>M</Arg> over a (qoutient of a) path algebra
   <Math>A</Math>. The projective presentation, or resolution is over
   the path algebra form which <Math>A</Math> was constructed.
   </Returns>
   <Description>
     This function takes as input a PathAlgebraMatModule and
     constructs a projetive presentation of this module over the path
     algebra over which it is defined, ie. a projetive resolution of
     length 1. It returns a list of five elements: (1) a projective
     module <Math>P</Math> over the path algebra, which modulo the
     relations induced the projective cover of <Arg>M</Arg>, (2) a
     submodule <Math>U</Math> of <Math>P</Math> such that
     <Math>P/U</Math> is isomorphic to <Arg>M</Arg>, (3) module
     generators of <Math>P</Math>, (4) module generators for
     <Math>U</Math> which forms a completely reduced right Groebner
     basis for <Math>U</Math>, and (5) a matrix with enteries in the
     path algebra which gives the map from <Math>U</Math> to
     <Math>P</Math>, if <Math>U</Math> were considered a direct sum of
     vertex projective modules over the path algebra.
   </Description>
</ManSection>

<ManSection>
  <Attr Name="RightGroebnerBasisOfModule" Arg="M" Comm="for a PathAlgebraModule"/>
  <Description> 
    Arguments: <Arg>M</Arg> -- a PathAlgebraModule. 
  <Br /></Description>
  <Returns>a right Groebner basis for the module <Arg>M</Arg>.</Returns>
  <Description>
    It checks if the acting algebra on the module <Arg>M</Arg> is a path algebra, 
    and it returns an error message otherwise. The elements in the right Groebner
    basis that is constructed, can be retrieved by the command <C>BasisVectors</C>. 
    The underlying module is likewise returned by the command <C>UnderlyingModule</C>. 
    The output of the function is satisfying the filter/category 
    <C>IsRightPathAlgebraModuleGroebnerBasis</C>. 
  </Description>
</ManSection>

<ManSection>
   <Oper Name="TargetVertex" Arg="v" Comm="for a PathAlgebraVector element"/>
   <Description> 
    Arguments: <Arg>v</Arg> -- a PathAlgebraVector.
   <Br /></Description>
   <Returns>a vertex <Math>w</Math> such that <Math>v*w = v</Math>, if
   such a vertex exists, and fail otherwise.
   </Returns>
   <Description>
     Given a PathAlgebraVector <Arg>v</Arg>, if <Arg>v</Arg> is right
     uniform, this function finds the vertex <Math>w</Math> such that
     <Math>v*w = v</Math> whenever <Arg>v</Arg> is non-zero, and
     returns the zero path otherwise. If <Arg>v</Arg> is not right
     uniform it returns fail.
   </Description>
</ManSection>

<ManSection>
   <Attr Name="UniformGeneratorsOfModule" Arg="M" Comm="for a PathAlgebraModule"/>
   <Description> 
   Arguments: <Arg>M</Arg> -- a <C>PathAlgebraModule</C>.
   <Br /></Description>
   <Returns>a set of right uniform generators of the mdoule <Arg>M</Arg>.  If  
   <Arg>M</Arg> is the zero module, then it returns an empty list. 
   </Returns>
</ManSection>

<ManSection>
  <Func Name="Vectorize" Arg="M, components" 
	Comm=""/>
  <Description> 
    Arguments: <Arg>M</Arg> -- a module over a path algebra, <Arg>components</Arg> -- a list of elements of <Arg>M</Arg>.
  <Br /></Description>
  <Returns>a vector in <Arg>M</Arg> from a list of path
  algebra elements <Arg>components</Arg>, which defines the
  components in the resulting vector.</Returns>
  <Description>
    The returned vector is normalized, so the vector's components
    may not match the input components.
  </Description>
</ManSection>

</Section>
</Chapter>
