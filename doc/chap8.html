<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (QPA) - Chapter 8: Homological algebra</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap8"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap7.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap9.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap8_mj.html">[MathJax on]</a></p>
<p><a id="X7D310EDE847865C1" name="X7D310EDE847865C1"></a></p>
<div class="ChapSects"><a href="chap8.html#X7D310EDE847865C1">8 <span class="Heading">Homological algebra</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap8.html#X7D310EDE847865C1">8.1 <span class="Heading">Homological algebra</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7EC01D588141BB96">8.1-1 1stSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7902D1477B9FF116">8.1-2 AllComplementsOfAlmostCompleteTiltingModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X81479679781E04FA">8.1-3 CotiltingModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7D6AD2AB87865333">8.1-4 DominantDimensionOfAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X8582841B79A11466">8.1-5 DominantDimensionOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7B9209CD7A46F544">8.1-6 ExtAlgebraGenerators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X787217547958E9C3">8.1-7 ExtOverAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7A7BF8178390DB7A">8.1-8 FaithfulDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7B2001337C48B3C9">8.1-9 GlobalDimensionOfAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X8380C47D80FAAED8">8.1-10 GorensteinDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X84BC33C07B4BBBC0">8.1-11 GorensteinDimensionOfAlgebra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7B1A0308813BA30F">8.1-12 HaveFiniteCoresolutionInAddM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X83271D587CD605E1">8.1-13 HaveFiniteResolutionInAddM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X80C6D02F7B543CC9">8.1-14 InjDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7C16FB658383C36F">8.1-15 InjDimensionOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X8434C5FC87773723">8.1-16 InjectiveEnvelope</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X81910CD67E69BBF4">8.1-17 IsCotiltingModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7AA1E69C7A1009DA">8.1-18 IsNthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7BE6A5B586463067">8.1-19 IsOmegaPeriodic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7CA63DA785F30E99">8.1-20 IsTtiltingModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7B433C86806B60A4">8.1-21 IyamaGenerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X80800F4F80398356">8.1-22 LeftApproximationByAddTHat</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X806A7DF7864D9431">8.1-23 LeftFacMApproximation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X82720AAD7E80714B">8.1-24 LeftMutationOfTiltingModuleComplement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X86EB50377F2E910D">8.1-25 LeftSubMApproximation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X848B51017E269802">8.1-26 LiftingInclusionMorphisms</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7A10EF0587ADA535">8.1-27 LiftingMorphismFromProjective</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X853E593B83DDD4B8">8.1-28 LeftApproximationByAddM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7F689558823AC784">8.1-29 RightApproximationByAddM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7947619F7C8539E0">8.1-30 RadicalRightApproximationByAddM</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X87AB8D2E8660869D">8.1-31 MorphismOnKernel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7EB51A487B5B239D">8.1-32 NthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X788CD7B282582D93">8.1-33 NumberOfComplementsOfAlmostCompleteTiltingModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7D3A779D7EFF32D1">8.1-34 ProjDimension</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X86DA085884BAF968">8.1-35 ProjDimensionOfModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X83257E2F7F8E0068">8.1-36 ProjectiveCover</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X8346B3997D9AB706">8.1-37 ProjectiveResolutionOfPathAlgebraModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X80678790799AEC16">8.1-38 ProjectiveResolutionOfSimpleModuleOverEndo</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7C705F2A79F8E43C">8.1-39 PullBack</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X81A2D49D85923894">8.1-40 PushOut</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X7C8B72157BDE0957">8.1-41 RightApproximationByPerpT</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X873C632A83DF48E2">8.1-42 RightFacMApproximation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X8018953F7951F8F2">8.1-43 RightMutationOfTiltingModuleComplement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X81BD4EEA831D4A54">8.1-44 RightSubMApproximation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X78CA656D7D4F2446">8.1-45 N_RigidModule</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap8.html#X824D52847879AB91">8.1-46 TiltingModule</a></span>
</div></div>
</div>

<h3>8 <span class="Heading">Homological algebra</span></h3>

<p>This chapter describes the homological algebra that is implemented in QPA.</p>

<p>The example used throughout this chapter is the following.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := Quiver(3,[[1,2,"a"],[1,2,"b"],[2,2,"c"],[2,3,"d"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3,1,"e"]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KQ := PathAlgebra(Rationals, Q);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(KQ);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rels := [d*e,c^2,a*c*d-b*d,e*a];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := KQ/rels;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [["a",[[1,2],[0,3],[1,5]]],["b",[[2,0],[3,0],[5,0]]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">["c",[[0,0],[1,0]]],["d",[[1,2],[0,1]]],["e",[[0,0,0],[0,0,0]]]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := RightModuleOverPathAlgebra(A,mat);;</span>
</pre></div>

<p><a id="X7D310EDE847865C1" name="X7D310EDE847865C1"></a></p>

<h4>8.1 <span class="Heading">Homological algebra</span></h4>

<p><a id="X7EC01D588141BB96" name="X7EC01D588141BB96"></a></p>

<h5>8.1-1 1stSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; 1stSyzygy</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: the first syzygy of the representation <var class="Arg">M</var> as a representation.</p>

<p><a id="X7902D1477B9FF116" name="X7902D1477B9FF116"></a></p>

<h5>8.1-2 AllComplementsOfAlmostCompleteTiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllComplementsOfAlmostCompleteTiltingModule</code>( <var class="Arg">M</var>, <var class="Arg">X</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllComplementsOfAlmostCompleteCotiltingModule</code>( <var class="Arg">M</var>, <var class="Arg">X</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">X</var> - two PathAlgebraMatModule's.<br /></p>

<p>Returns: all the complements of the almost complete (co-)tilting module <var class="Arg">M</var> as two exact sequences, the first is all complements which are gotten as an <var class="Arg">add M</var>-resolution of <var class="Arg">X</var> and the second is all complements which are gotten as an <var class="Arg">add M</var>-coresolution of <var class="Arg">X</var>. If there are no complements to the left of <var class="Arg">X</var>, then an empty list is returned. Similarly for to the right of <var class="Arg">X</var>. In particular, if <var class="Arg">X</var> has no other complements the list <code class="code">[[],[]]</code> is returned.</p>

<p><a id="X81479679781E04FA" name="X81479679781E04FA"></a></p>

<h5>8.1-3 CotiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CotiltingModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">n</var> - a PathAlgebraMatModule and a positive integer.<br /></p>

<p>Returns: false if <var class="Arg">M</var> is not a cotilting module of injective dimension at most <var class="Arg">a</var>. Otherwise, it returns the injective dimension of <var class="Arg">M</var> and the resolution of all indecomposable injective modules in <var class="Arg">add M</var>.</p>

<p><a id="X7D6AD2AB87865333" name="X7D6AD2AB87865333"></a></p>

<h5>8.1-4 DominantDimensionOfAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantDimensionOfAlgebra</code>( <var class="Arg">A</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var>, <var class="Arg">n</var> - a quiver algebra, a positive integer.<br /></p>

<p>Returns: the dominant dimension of the algebra <var class="Arg">A</var> if the dominant dimension is less or equal to <var class="Arg">n</var>. If the function can decide that the dominant dimension is infinite, it returns <code class="code">infinity</code>. Otherwise, if the dominant dimension is larger than <var class="Arg">n</var>, then it returns <code class="code">false</code>.</p>

<p><a id="X8582841B79A11466" name="X8582841B79A11466"></a></p>

<h5>8.1-5 DominantDimensionOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominantDimensionOfModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">n</var> - a PathAlgebraMatModule, a positive integer.<br /></p>

<p>Returns: the dominant dimension of the module <var class="Arg">M</var> if the dominant dimension is less or equal to <var class="Arg">n</var>. If the function can decide that the dominant dimension is infinite, it returns <code class="code">infinity</code>. Otherwise, if the dominant dimension is larger than <var class="Arg">n</var>, then it returns <code class="code">false</code>.</p>

<p><a id="X7B9209CD7A46F544" name="X7B9209CD7A46F544"></a></p>

<h5>8.1-6 ExtAlgebraGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtAlgebraGenerators</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a module, <var class="Arg">n</var> - a positive integer.<br /></p>

<p>Returns: a list of three elements, where the first element is the dimensions of Ext^[0..n](M,M), the second element is the number of minimal generators in the degrees [0..n], and the third element is the generators in these degrees.</p>

<p>This function computes the generators of the Ext-algebra <span class="Math">Ext^*(M,M)</span> up to degree <var class="Arg">n</var>.</p>

<p><a id="X787217547958E9C3" name="X787217547958E9C3"></a></p>

<h5>8.1-7 ExtOverAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtOverAlgebra</code>( <var class="Arg">M</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">N</var> - two modules.<br /></p>

<p>Returns: a list of three elements <code class="func">ExtOverAlgebra</code>, where the first element is the map from the first syzygy, <span class="SimpleMath">Ω(M)</span> to the projective cover, <span class="SimpleMath">P(M)</span> of the module <var class="Arg">M</var>, the second element is a basis of <span class="Math">\Ext^1(M,N)</span> in terms of elements in <span class="Math">\Hom(\Omega(M),N)</span> and the third element is a function that takes as an argument a homomorphism in <code class="code">Hom(Omega(M),N)</code> and returns the coefficients of this element when written in terms of the basis of <span class="Math">\Ext^1(M,N)</span>.</p>

<p>The function checks if the arguments <var class="Arg">M</var> and <var class="Arg">N</var> are modules of the same algebra, and returns an error message otherwise. It <span class="Math">\Ext^1(M,N)</span> is zero, an empty list is returned.</p>

<p><a id="X7A7BF8178390DB7A" name="X7A7BF8178390DB7A"></a></p>

<h5>8.1-8 FaithfulDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; FaithfulDimension</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a PathAlgebraMatModule.<br /></p>

<p>Returns: the faithful dimension of the module <var class="Arg">M</var>.</p>

<p><a id="X7B2001337C48B3C9" name="X7B2001337C48B3C9"></a></p>

<h5>8.1-9 GlobalDimensionOfAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GlobalDimensionOfAlgebra</code>( <var class="Arg">A</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var>, <var class="Arg">n</var> - a quiver algebra, a positive integer.<br /></p>

<p>Returns: the global dimension of <var class="Arg">A</var> if the global dimension is less or equal to <var class="Arg">n</var>. If the function can decide that the global dimension is infinite, it returns <code class="code">infinity</code>. Otherwise, if the global dimension is larger than <var class="Arg">n</var>, then it returns <code class="code">false</code>.</p>

<p><a id="X8380C47D80FAAED8" name="X8380C47D80FAAED8"></a></p>

<h5>8.1-10 GorensteinDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GorensteinDimension</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var> - a quiver algebra.<br /></p>

<p>Returns: the Gorenstein dimension of <var class="Arg">A</var>, if the Gorenstein dimension has been computed. Otherwise it returns an error message.</p>

<p><a id="X84BC33C07B4BBBC0" name="X84BC33C07B4BBBC0"></a></p>

<h5>8.1-11 GorensteinDimensionOfAlgebra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GorensteinDimensionOfAlgebra</code>( <var class="Arg">A</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">A</var>, <var class="Arg">n</var> - a quiver algebra, a positive integer.<br /></p>

<p>Returns: the Gorenstein dimension of <var class="Arg">A</var> if the Gorenstein dimension is less or equal to <var class="Arg">n</var>. Otherwise, if the Gorenstein dimension is larger than <var class="Arg">n</var>, then it returns <code class="code">false</code>.</p>

<p><a id="X7B1A0308813BA30F" name="X7B1A0308813BA30F"></a></p>

<h5>8.1-12 HaveFiniteCoresolutionInAddM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HaveFiniteCoresolutionInAddM</code>( <var class="Arg">N</var>, <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">N</var>, <var class="Arg">M</var>, <var class="Arg">n</var> - two PathAlgebraMatModule's and an integer.<br /></p>

<p>Returns: false if <var class="Arg">N</var> does not have a coresolution of length at most <var class="Arg">n</var> in <var class="Arg">add M</var>, otherwise it returns the coresolution of <var class="Arg">N</var> of length at most <var class="Arg">n</var>.</p>

<p><a id="X83271D587CD605E1" name="X83271D587CD605E1"></a></p>

<h5>8.1-13 HaveFiniteResolutionInAddM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HaveFiniteResolutionInAddM</code>( <var class="Arg">N</var>, <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">N</var>, <var class="Arg">M</var>, <var class="Arg">n</var> - two PathAlgebraMatModule's and an integer.<br /></p>

<p>Returns: false if <var class="Arg">N</var> does not have a resolution of length at most <var class="Arg">n</var> in <var class="Arg">add M</var>, otherwise it returns the resolution of <var class="Arg">N</var> of length at most <var class="Arg">n</var>.</p>

<p><a id="X80C6D02F7B543CC9" name="X80C6D02F7B543CC9"></a></p>

<h5>8.1-14 InjDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjDimension</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a PathAlgebraMatModule.<br /></p>

<p>If the injective dimension of the module <var class="Arg">M</var> has been computed, then the projective dimension is returned.</p>

<p><a id="X7C16FB658383C36F" name="X7C16FB658383C36F"></a></p>

<h5>8.1-15 InjDimensionOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjDimensionOfModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M, n</var> - a PathAlgebraMatModule, a positive integer.<br /></p>

<p>Returns: Returns the injective dimension of the module <var class="Arg">M</var> if it is less or equal to <var class="Arg">n</var>. Otherwise it returns false.</p>

<p><a id="X8434C5FC87773723" name="X8434C5FC87773723"></a></p>

<h5>8.1-16 InjectiveEnvelope</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjectiveEnvelope</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a module.<br /></p>

<p>Returns: the injective envelope of <var class="Arg">M</var>, that is, returns the map <span class="Math">M\to I(M)</span>.</p>

<p>If the module <var class="Arg">M</var> is zero, then the zero map from <var class="Arg">M</var> is returned.</p>

<p><a id="X81910CD67E69BBF4" name="X81910CD67E69BBF4"></a></p>

<h5>8.1-17 IsCotiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCotiltingModule</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a PathAlgebraMatModule.<br /></p>

<p>Returns: true if the module <var class="Arg">M</var> has been checked to be a cotilting mdoule, otherwise it returns an error message.</p>

<p><a id="X7AA1E69C7A1009DA" name="X7AA1E69C7A1009DA"></a></p>

<h5>8.1-18 IsNthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsNthSyzygy</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- a positive integer. <br /></p>

<p>Returns: <code class="code">true</code>, if the representation <var class="Arg">M</var> is isomorphic to a direct summand of an <var class="Arg">n</var>-th syzygy of some module or is a projective module, and false otherwise.</p>

<p><a id="X7BE6A5B586463067" name="X7BE6A5B586463067"></a></p>

<h5>8.1-19 IsOmegaPeriodic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsOmegaPeriodic</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- a positive integer. <br /></p>

<p>Returns: <code class="code">i</code>, where <code class="code">i</code> is the smallest positive integer less or equal <code class="code">n</code> such that the representation <var class="Arg">M</var> is isomorphic to the <code class="code">i</code>-th syzygy of <var class="Arg">M</var>, and false otherwise.</p>

<p><a id="X7CA63DA785F30E99" name="X7CA63DA785F30E99"></a></p>

<h5>8.1-20 IsTtiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsTtiltingModule</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a PathAlgebraMatModule.<br /></p>

<p>Returns: true if the module <var class="Arg">M</var> has been checked to be a tilting mdoule, otherwise it returns an error message.</p>

<p><a id="X7B433C86806B60A4" name="X7B433C86806B60A4"></a></p>

<h5>8.1-21 IyamaGenerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IyamaGenerator</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a module <span class="Math">N</span> such that <var class="Arg">M</var> is a direct summand of <span class="Math">N</span> and such that the global dimension of the endomorphism ring of <span class="Math">N</span> is finite using the algorithm provided by Osamu Iyama (add reference here).</p>

<p><a id="X80800F4F80398356" name="X80800F4F80398356"></a></p>

<h5>8.1-22 LeftApproximationByAddTHat</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftApproximationByAddTHat</code>( <var class="Arg">T</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">T</var>, <var class="Arg">M</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: the minimal left <span class="SimpleMath">widehatadd T</span>-approximation of <var class="Arg">M</var>.</p>

<p>The function checks if the first argument is a cotilting module, that is, checks if the attribute of <code class="code">IsCotiltingModule</code> is set. This attribute can be set by giving the command <code class="code">CotiltingModule( T, n )</code> for some positive integer <code class="code">n</code> which is at least the injective dimension of the module <var class="Arg">T</var>.</p>

<p><a id="X806A7DF7864D9431" name="X806A7DF7864D9431"></a></p>

<h5>8.1-23 LeftFacMApproximation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftFacMApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftFacMApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">C</var>, <var class="Arg">M</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a left <span class="Math">\operatorname{Fac} M</span>-approximation of the module <span class="Math">C</span>, where the first version returns a not necessarily minimal left <span class="Math">\operatorname{Fac} M</span>-approximation and the second returns a minimal approximation.</p>

<p><a id="X82720AAD7E80714B" name="X82720AAD7E80714B"></a></p>

<h5>8.1-24 LeftMutationOfTiltingModuleComplement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftMutationOfTiltingModuleComplement</code>( <var class="Arg">M</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftMutationOfCotiltingModuleComplement</code>( <var class="Arg">M</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a left mutation of the complement <var class="Arg">N</var> of the almost complete tilting/cotilting module <var class="Arg">M</var>, if such a complement exists. Otherwise it returns false.</p>

<p><a id="X86EB50377F2E910D" name="X86EB50377F2E910D"></a></p>

<h5>8.1-25 LeftSubMApproximation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftSubMApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftSubMApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">C</var>, <var class="Arg">M</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a minimal left <span class="Math">\operatorname{Sub} M</span>-approximation of the module <span class="Math">C</span>.</p>

<p><a id="X848B51017E269802" name="X848B51017E269802"></a></p>

<h5>8.1-26 LiftingInclusionMorphisms</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftingInclusionMorphisms</code>( <var class="Arg">f</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var>, <var class="Arg">g</var> - two homomorphisms with common range.<br /></p>

<p>Returns: a factorization of <var class="Arg">g</var> in terms of <var class="Arg">f</var>, whenever possible and <code class="code">fail</code> otherwise.</p>

<p>Given two inclusions <span class="Math">f\colon B\to C</span> and <span class="Math">g\colon A\to C</span>, this function constructs a morphism from <span class="Math">A</span> to <span class="Math">B</span>, whenever the image of <var class="Arg">g</var> is contained in the image of <var class="Arg">f</var>. Otherwise the function returns fail. The function checks if <var class="Arg">f</var> and <var class="Arg">g</var> are one-to-one, if they have the same range and if the image of <var class="Arg">g</var> is contained in the image of <var class="Arg">f</var>.</p>

<p><a id="X7A10EF0587ADA535" name="X7A10EF0587ADA535"></a></p>

<h5>8.1-27 LiftingMorphismFromProjective</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftingMorphismFromProjective</code>( <var class="Arg">f</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var>, <var class="Arg">g</var> - two homomorphisms with common range.<br /></p>

<p>Returns: a factorization of <var class="Arg">g</var> in terms of <var class="Arg">f</var>, whenever possible and <code class="code">fail</code> otherwise.</p>

<p>Given two morphisms <span class="Math">f\colon B\to C</span> and <span class="Math">g\colon P\to C</span>, where <span class="Math">P</span> is a direct sum of indecomposable projective modules constructed via <code class="code">DirectSumOfQPAModules</code> and <var class="Arg">f</var> an epimorphism, this function finds a lifting of <var class="Arg">g</var> to <span class="Math">B</span>. The function checks if <span class="Math">P</span> is a direct sum of indecomposable projective modules, if <var class="Arg">f</var> is onto and if <var class="Arg">f</var> and <var class="Arg">g</var> have the same range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := BasisVectors(Basis(N));</span>
[ [ [ 1, 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 1, 0 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 1 ], [ 0, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 1, 0 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1 ], [ 0, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 1, 0 ] ], 
  [ [ 0, 0, 0 ], [ 0, 0 ], [ 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := SubRepresentationInclusion(N,[B[1],B[4]]);</span>
&lt;&lt;[ 1, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := SubRepresentationInclusion(N,[B[1],B[2]]);</span>
&lt;&lt;[ 2, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftingInclusionMorphisms(f,g);</span>
&lt;&lt;[ 1, 2, 2 ]&gt; ---&gt; &lt;[ 2, 2, 2 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SimpleModules(A); </span>
[ &lt;[ 1, 0, 0 ]&gt;, &lt;[ 0, 1, 0 ]&gt;, &lt;[ 0, 0, 1 ]&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">homNS := HomOverAlgebra(N,S[1]);</span>
[ &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 1, 0, 0 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 1, 0, 0 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 1, 0, 0 ]&gt;&gt;
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := homNS[1];</span>
&lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 1, 0, 0 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := ProjectiveCover(S[1]);</span>
&lt;&lt;[ 1, 4, 3 ]&gt; ---&gt; &lt;[ 1, 0, 0 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftingMorphismFromProjective(f,p);</span>
&lt;&lt;[ 1, 4, 3 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
[ [(1)*v1], [(1)*v2], [(1)*v3], [(1)*a], [(1)*b], [(1)*c], [(1)*d], [(1)*e] 
 ] )&gt; &gt; 
</pre></div>

<p><a id="X853E593B83DDD4B8" name="X853E593B83DDD4B8"></a></p>

<h5>8.1-28 LeftApproximationByAddM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LeftApproximationByAddM</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftAddMApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalLeftApproximation</code>( <var class="Arg">C</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">C</var>, <var class="Arg">M</var> - two modules.<br /></p>

<p>Returns: the minimal left <span class="SimpleMath">add M</span>-approximation in the two last versions of the module <var class="Arg">C</var>. In the first it returns some left approximation. Note: The order of the arguments is opposite of the order for minimal right approximations.</p>

<p><a id="X7F689558823AC784" name="X7F689558823AC784"></a></p>

<h5>8.1-29 RightApproximationByAddM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightApproximationByAddM</code>( <var class="Arg">M</var>, <var class="Arg">C/modulelist</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightAddMApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">C</var> - two modules.<br /></p>

<p>Returns: the minimal right <span class="SimpleMath">add M</span>-approximation in the two last versions of the module <var class="Arg">C</var>. In the two first it returns some right approximation, where in the first version the input is two modules, while in the second version the input is a list of modules and a module. Note: The order of the arguments is opposite of the order for minimal left approximations.</p>

<p><a id="X7947619F7C8539E0" name="X7947619F7C8539E0"></a></p>

<h5>8.1-30 RadicalRightApproximationByAddM</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RadicalRightApproximationByAddM</code>( <var class="Arg">modulelist</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">modulelist</var>, <var class="Arg">t</var> - a list of modules and an index of this list.<br /></p>

<p>Returns: a radical right approximation of <code class="code">moduleslist[ t ]</code> by the additive closure of the modules in the list of modules <var class="Arg">modulelist</var>, that is, returns a homomorphism <span class="SimpleMath">f: M_M_t -&gt; M_t</span>, where <span class="SimpleMath">M_t</span> is the t-th module in the <var class="Arg">modulelist</var>.</p>

<p><a id="X87AB8D2E8660869D" name="X87AB8D2E8660869D"></a></p>

<h5>8.1-31 MorphismOnKernel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismOnKernel</code>( <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">alpha</var>, <var class="Arg">beta</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismOnImage</code>( <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">alpha</var>, <var class="Arg">beta</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MorphismOnCoKernel</code>( <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">alpha</var>, <var class="Arg">beta</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">alpha</var>, <var class="Arg">beta</var> - four homomorphisms of modules.<br /></p>

<p>Returns: the morphism induced on the kernels, the images or the cokernels of the morphisms <var class="Arg">f</var> and <var class="Arg">g</var>, respectively, whenever <span class="SimpleMath">f: A-&gt; B</span>, <span class="SimpleMath">β: B-&gt; B'</span>, <span class="SimpleMath">α: A-&gt; A'</span> and <span class="SimpleMath">g: A'-&gt; B'</span> forms a commutative diagram.</p>

<p>It is checked if <var class="Arg">f</var>, <var class="Arg">g</var>, <var class="Arg">alpha</var>, <var class="Arg">beta</var> forms a commutative diagram, that is, if <span class="Math">f \beta - \alpha g = 0</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom := HomOverAlgebra(N,N);</span>
[ &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
    , &lt;&lt;[ 3, 2, 2 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := MorphismOnKernel(hom[1],hom[2],hom[1],hom[2]);</span>
&lt;&lt;[ 2, 2, 2 ]&gt; ---&gt; &lt;[ 2, 2, 2 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphicModules(Source(g),Range(g));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := ProjectiveCover(N);</span>
&lt;&lt;[ 3, 12, 9 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N1 := Kernel(p);</span>
&lt;[ 0, 10, 7 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pullback := PullBack(p,hom[1]);</span>
[ &lt;&lt;[ 3, 12, 9 ]&gt; ---&gt; &lt;[ 3, 2, 2 ]&gt;&gt;
    , &lt;&lt;[ 3, 12, 9 ]&gt; ---&gt; &lt;[ 3, 12, 9 ]&gt;&gt;
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel(pullback[1]);</span>
&lt;[ 0, 10, 7 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphicModules(N1,Kernel(pullback[1]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := LiftingMorphismFromProjective(p,p*hom[1]);</span>
&lt;&lt;[ 3, 12, 9 ]&gt; ---&gt; &lt;[ 3, 12, 9 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := MorphismOnKernel(p,p,t,hom[1]);    </span>
&lt;&lt;[ 0, 10, 7 ]&gt; ---&gt; &lt;[ 0, 10, 7 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(s) = N1;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := KernelInclusion(p);</span>
&lt;&lt;[ 0, 10, 7 ]&gt; ---&gt; &lt;[ 3, 12, 9 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pushout := PushOut(q,s);</span>
[ &lt;&lt;[ 0, 10, 7 ]&gt; ---&gt; &lt;[ 3, 12, 9 ]&gt;&gt;
    , &lt;&lt;[ 3, 12, 9 ]&gt; ---&gt; &lt;[ 3, 12, 9 ]&gt;&gt;
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := CoKernel(pushout[1]);</span>
&lt;[ 3, 2, 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphicModules(U,N);</span>
true 
</pre></div>

<p><a id="X7EB51A487B5B239D" name="X7EB51A487B5B239D"></a></p>

<h5>8.1-32 NthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NthSyzygy</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> -- a non-negative integer. <br /></p>

<p>Returns: the <var class="Arg">n</var>-th syzygy of <var class="Arg">M</var>.</p>

<p>This functions computes a projective resolution of <var class="Arg">M</var> and finds the <var class="Arg">n</var>-th syzygy of the module <var class="Arg">M</var>.</p>

<p><a id="X788CD7B282582D93" name="X788CD7B282582D93"></a></p>

<h5>8.1-33 NumberOfComplementsOfAlmostCompleteTiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfComplementsOfAlmostCompleteTiltingModule</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NumberOfComplementsOfAlmostCompleteCotiltingModule</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> -- a PathAlgebraMatModule.<br /></p>

<p>Returns: the number complements of an almost complete tilting/cotilting module <var class="Arg">M</var>, assuming that <var class="Arg">M</var> is an almost complete tilting module.</p>

<p><a id="X7D3A779D7EFF32D1" name="X7D3A779D7EFF32D1"></a></p>

<h5>8.1-34 ProjDimension</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjDimension</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a PathAlgebraMatModule.<br /></p>

<p>Returns: the projective dimension of the module <var class="Arg">M</var>, if it has been computed.</p>

<p><a id="X86DA085884BAF968" name="X86DA085884BAF968"></a></p>

<h5>8.1-35 ProjDimensionOfModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjDimensionOfModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M, n</var> - a PathAlgebraMatModule, a positive integer.<br /></p>

<p>Returns: Returns the projective dimension of the module <var class="Arg">M</var> if it is less or equal to <var class="Arg">n</var>. Otherwise it returns false.</p>

<p><a id="X83257E2F7F8E0068" name="X83257E2F7F8E0068"></a></p>

<h5>8.1-36 ProjectiveCover</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveCover</code>( <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a module.<br /></p>

<p>Returns: the projective cover of <var class="Arg">M</var>, that is, returns the map <span class="Math">P(M)\to M</span>.</p>

<p>If the module <var class="Arg">M</var> is zero, then the zero map to <var class="Arg">M</var> is returned.</p>

<p><a id="X8346B3997D9AB706" name="X8346B3997D9AB706"></a></p>

<h5>8.1-37 ProjectiveResolutionOfPathAlgebraModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveResolutionOfPathAlgebraModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var> - a path algebra module (<code class="code">PathAlgebraMatModule</code>), <var class="Arg">n</var> - a positive integer.<br /></p>

<p>Returns: in terms of attributes <code class="code">RProjectives</code>, <code class="code">ProjectivesFList</code> and <code class="code">Maps</code> a projective resolution of <var class="Arg">M</var> out to stage <var class="Arg">n</var>, where <code class="code">RProjectives</code> are the projectives in the resolution lifted up to projectives over the path algebra, <code class="code">ProjectivesFList</code> are the generators of the projective modules given in <code class="code">RProjectives</code> in terms of elements in the first projective in the resolution and <code class="code">Maps</code> contains the information about the maps in the resolution.</p>

<p>The algorithm for computing this projective resolution is based on the paper <a href="chapBib.html#biBGreenSolbergZacharia">[GSZ01]</a>. In addition, the algebra over which the modules are defined is available via the attribute <code class="code">ParentAlgebra</code>.</p>

<p><a id="X80678790799AEC16" name="X80678790799AEC16"></a></p>

<h5>8.1-38 ProjectiveResolutionOfSimpleModuleOverEndo</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectiveResolutionOfSimpleModuleOverEndo</code>( <var class="Arg">modulelist</var>, <var class="Arg">t</var>, <var class="Arg">length</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">modulelist</var> - a list of module, <var class="Arg">t</var> - an index of the list of modules, <var class="Arg">length</var> - length of the resolution.<br /></p>

<p>Returns: information about the projective dimension and non-projective summands of the syzygies of the simple module corresponding to the <var class="Arg">t</var>-th indecomposable projective module over the endomorphism ring of the direct sum of all the modules in <var class="Arg">modulelist</var> (all assumed to be indecomposable). The non-projective summands in the syzygies from the second syzygy up to the <var class="Arg">length</var>-syzygy are always returned. If the projective dimension is less or equal to <var class="Arg">length</var>, the projective dimension is returned. Otherwise, it returns that the projective dimension is bigger that <var class="Arg">length</var>. The output has the format <code class="code">[ info on projective dimension, syzygies ]</code>.</p>

<p><a id="X7C705F2A79F8E43C" name="X7C705F2A79F8E43C"></a></p>

<h5>8.1-39 PullBack</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PullBack</code>( <var class="Arg">f</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var>, <var class="Arg">g</var> - two homomorphisms with a common range.<br /></p>

<p>Returns: the pullback of the maps <var class="Arg">f</var> and <var class="Arg">g</var>.</p>

<p>It is checked if <var class="Arg">f</var> and <var class="Arg">g</var> have the same range. Given the input <span class="Math">f\colon A\to B</span> (horizontal map) and <span class="Math">g\colon C\to B</span> (vertical map), the pullback <span class="Math">E</span> is returned as the two homomorphisms <span class="Math">[f',g']</span>, where <span class="Math">f'\colon E\to C</span> (horizontal map) and <span class="Math">g'\colon E\to A</span> (vertical map).</p>

<p><a id="X81A2D49D85923894" name="X81A2D49D85923894"></a></p>

<h5>8.1-40 PushOut</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PushOut</code>( <var class="Arg">f</var>, <var class="Arg">g</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">f</var>, <var class="Arg">g</var> - two homomorphisms between modules with a common source.<br /></p>

<p>Returns: the pushout of the maps <var class="Arg">f</var> and <var class="Arg">g</var>.</p>

<p>It is checked if <var class="Arg">f</var> and <var class="Arg">g</var> have the same source. Given the input <span class="Math">f\colon A\to B</span> (horizontal map) and <span class="Math">g\colon A\to C</span> (vertical map), the pushout <span class="Math">E</span> is returned as the two homomorphisms <span class="Math">[f',g']</span>, where <span class="Math">f'\colon C\to E</span> (horizontal map) and <span class="Math">g'\colon B\to E</span> (vertical map).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := SimpleModules(A);</span>
[ &lt;[ 1, 0, 0 ]&gt;, &lt;[ 0, 1, 0 ]&gt;, &lt;[ 0, 0, 1 ]&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ext := ExtOverAlgebra(S[2],S[2]);</span>
[ &lt;&lt;[ 0, 1, 2 ]&gt; ---&gt; &lt;[ 0, 2, 2 ]&gt;&gt;
    , [ &lt;&lt;[ 0, 1, 2 ]&gt; ---&gt; &lt;[ 0, 1, 0 ]&gt;&gt;
         ], function( map ) ... end ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(Ext[2]);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># i.e. Ext^1(S[2],S[2]) is 1-dimensional</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pushout := PushOut(Ext[2][1],Ext[1]);   </span>
[ &lt;&lt;[ 0, 2, 2 ]&gt; ---&gt; &lt;[ 0, 2, 0 ]&gt;&gt;
    , &lt;&lt;[ 0, 1, 0 ]&gt; ---&gt; &lt;[ 0, 2, 0 ]&gt;&gt;
     ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := CoKernelProjection(pushout[1]);</span>
&lt;&lt;[ 0, 2, 0 ]&gt; ---&gt; &lt;[ 0, 0, 0 ]&gt;&gt;

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := Range(pushout[1]); </span>
&lt;[ 0, 2, 0 ]&gt; 
</pre></div>

<p><a id="X7C8B72157BDE0957" name="X7C8B72157BDE0957"></a></p>

<h5>8.1-41 RightApproximationByPerpT</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightApproximationByPerpT</code>( <var class="Arg">T</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">T</var>, <var class="Arg">M</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: the minimal right <span class="SimpleMath">^perp T</span>-approximation of <var class="Arg">M</var>.</p>

<p>The function checks if the first argument is a cotilting module, that is, checks if the attribute of <code class="code">IsCotiltingModule</code> is set. This attribute can be set by giving the command <code class="code">CotiltingModule( T, n )</code> for some positive integer <code class="code">n</code> which is at least the injective dimension of the module <var class="Arg">T</var>.</p>

<p><a id="X873C632A83DF48E2" name="X873C632A83DF48E2"></a></p>

<h5>8.1-42 RightFacMApproximation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightFacMApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightFacMApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">C</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a minimal right <span class="Math">\operatorname{Fac} M</span>-approximation of the module <span class="Math">C</span>.</p>

<p><a id="X8018953F7951F8F2" name="X8018953F7951F8F2"></a></p>

<h5>8.1-43 RightMutationOfTiltingModuleComplement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightMutationOfTiltingModuleComplement</code>( <var class="Arg">M</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightMutationOfCotiltingModuleComplement</code>( <var class="Arg">M</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">N</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a right mutation of the complement <var class="Arg">N</var> of the almost complete tilting/cotilting module <var class="Arg">M</var>, if such a complement exists. Otherwise it returns false.</p>

<p><a id="X81BD4EEA831D4A54" name="X81BD4EEA831D4A54"></a></p>

<h5>8.1-44 RightSubMApproximation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RightSubMApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalRightSubMApproximation</code>( <var class="Arg">M</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">C</var> -- two path algebra modules (<code class="code">PathAlgebraMatModule</code>). <br /></p>

<p>Returns: a right <span class="Math">\operatorname{Sub} M</span>-approximation of the module <span class="Math">C</span>, where the first version returns a not necessarily minimal right <span class="Math">\operatorname{Sub} M</span>-approximation and the second returns a minimal approximation.</p>

<p><a id="X78CA656D7D4F2446" name="X78CA656D7D4F2446"></a></p>

<h5>8.1-45 N_RigidModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; N_RigidModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">n</var> - a PathAlgebraMatModule, an integer.<br /></p>

<p>Returns: true if <var class="Arg">M</var> is a <var class="Arg">n</var>-rigid module. Otherwise it returns false.</p>

<p><a id="X824D52847879AB91" name="X824D52847879AB91"></a></p>

<h5>8.1-46 TiltingModule</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TiltingModule</code>( <var class="Arg">M</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">M</var>, <var class="Arg">n</var> - a PathAlgebraMatModule and a positive integer.<br /></p>

<p>Returns: false if <var class="Arg">M</var> is not a tilting module of projective dimension at most <var class="Arg">n</var>. Otherwise, it returns the projective dimension of <var class="Arg">M</var> and the coresolution of all indecomposable projective modules in <span class="SimpleMath">add M</span>.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap7.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap9.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
